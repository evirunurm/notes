Type system:
	Overview:
		Strongly typed:
			A method declaration specifies a name, type and kind of each input parameter and return value.
				Kind: value, reference, output.
			.NET class library --> built-in numeric types and complex types
				- File system
				- Network connections
				- Collections and arrays
				- Dates
			Information stored in a type:
				- Storage space a variable requires.
				- Max / min values represented.
				- Members it contains (methods, fields, events...).
				- Base type it inherits from.
				- Interfaces it implements.
				- Kinds of operations permitted.
			Compiler embeds the type information into the executable file as metadata. CLR uses that at runtime to guarantee type safety (allocation and reclaim of memory).

		Variable declaration:
			When declaring variable --> specify type or "var" keyword (type inferring).
			Redeclaring variable:
				You can't assign a value noy compatible with its declared type.
				But, values can be converted to other types (assigned to new variables, passed as arguments).
					- No data loss --> Automatic type conversion
					- Data loss --> Cast

		Built-in types:


	Namespaces:
		Uses:
			- Class organization (.NET)
				"using" directive obviated the requirement to specify the name of the namespace.
				.NET 6 SDK adds implicit global "using" directives
					- Microsoft.NET.Sdk
					- Microsoft.NET.Sdk.Web
					- Microsoft.NET.Sdk.Worker
					--> "global" namespace is the root.
			- Scope control of class and method names for large projects.
				C# 10+ --> a namespace can be declared for all types in that file as:
					namespace SampleNamespace;

	Classes:
		Reference type, contains null until instantiated.
		Class members: fields, properties, methods and events.
		Inheritance:	public class Son : Parent { //... }
			Inherits all the members except the constructors.
			Child can only inherit from one base class.
			"abstract": (Same as Java)
				- Can't be instantiated.
				- Must be derived from.
			"sealed": (Similar to final)
				- Cannot be derived from.

	Records:
		Class/struct that provides special syntax and behavior for working with data models
		Uses:
			- Define a data model that depends on value equality.
			- Define a type for which objects are immutable.
		Value equality:
			Two variables of a record type are equal if the types and all property / field values match.
		Immutability:
			Prevents you from changing any property or field value after it's instantiated.


























